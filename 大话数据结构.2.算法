   算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个。
   算法具有五个基本特性：输入、输出、有穷性、确定性和可行性。
   2.5.1 输入输出
   算法具有零个或多个输入。算法至少有一个或多个输出。
   2.5.2有穷性：指算法在执行优先的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间之内完成。
   2.5.3确定性：算法的每一个步骤都具有确定的含义，不会出现二义性。
   2.5.4可行性：算法的每一步都必须是可行的，也就是说每一步都能够通过执行有限次数完成。
   2.6算法设计的要求
   2.6.1正确性
   大致分为四个层次：
   1.算法程序没有语法错误。
   2.算法程序对于合法的输入数据能够产生满足要求的输出结果。
   3.算法程序对于非法的输入数据能够得出满足规格说明的结果。
   4.算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果。
   2.6.2可读性
   可读性：算法设计的另一个目的是为了便于阅读、理解和交流。
   2.6.3健壮性
   健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果。
   2.6.4时间效率高和存储量低
   设计算法应该尽量满足时间效率高和存储量低的需求。
   2.7算法效率的度量方法。
   2.7.1事后统计方法
   事后统计方法：这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编织的程序的运行时间进行比较，从而确定算法效率的高低。
   2.7.2事前分析估算法
      事前分析估算法：在计算机程序编制前，依据统计方法对算法进行估算。
      经过分析，我们发现，一个用高级程序语言编写的程序在计算机上运行时所消耗的时间取决于下列因素：
      1.算法采用的效率，方法。
      2.编译产生的代码质量。
      3.问题的输入规模。
      4.机器执行指令的速度。
      第1条当然是算法好坏的根本，第2条要由软件来支持，第4条要看硬件性能。也就是说，抛开这些与计算机硬件、软件有关的因素，一个程序的运行时间，依赖于算法的好坏和问题的输入规模。所谓问题的输入规模是指输入量的多少。
      2.8函数的渐近增大
      函数的渐近增大：给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n>N，f(n)总是比g(n)大，那么，我们说f(n)的增长渐近快于g(n)。
      2.9算法时间复杂度
      2.9.1算法时间复杂度定义
      在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度。也就是算法的时间量度，记作：T(n)＝O(f(n))。它表示随问题规模n的增大，算法执行时间的增大率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。
      我们用大写的O[]来体现算法的时间复杂度的记法，我们称之为大O记法。
      2.9.2推导大O阶方法
      推导大O阶：
      1.用常数1取代运算时间中的所有加法常数。
      2.在修改后的运行次数函数中，只保留最高阶项。
      3.如果最高阶项存在且不是1，则去除与这个项目相乘的常数。
      得到的结果就是大O阶。
      2.9.3常数阶
      对于1，不管常数是多少，我们都记为O(1)对于分支结构而言，无论是真，还是假，执行次数都是恒定的，不会随着n的变大而变化，所以单纯的分支结构（不包含在循环结构中），其时间复杂度也是O(1)。
      2.9.4线性阶
      我们要分析算法的复杂度，关键就是要分析循环结构的运算情况。
      2.9.5对数阶
      int count = 1;
      while (count < n)
      {
         count = count *2;
         /*
            时间复杂度为O(1)的程序步骤序列。
          */
      }
      由2的x方等于n的到x=log2n;
      2.9.6平方阶

      2.10常用的时间复杂度
      常用的时间复杂度所耗费的时间从小到大依次是：
      O(1)<O(logn)<O(n)<O(nlogn)<O(n的平方)<O(n的三次方)<O(2的n次方)<O(n!)<O(n的n次方)。
      2.11最坏情况和平均情况
      最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。在应用中，这是一种最重要的需求，通常，除非特别制定，我们提到运行时间都是最坏情况的运行时间。
      对算法分析，一种方法是计算所有情况的平均值，这种时间复杂度的计算方法称为平均时间复杂度。
      一般在没有特殊说明的情况下，都是指最坏时间复杂度。
      2.12算法空间复杂度
      算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n) = O(f(n))，其中，n为问题的规模，f(n)为语句关于n所占存储空间的函数。
      

